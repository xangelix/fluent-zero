use std::{env, fs, io::Write as _, path::Path};

use fluent_syntax::parser;
use unic_langid::LanguageIdentifier;

/// Generates the static cache code for `fluent-zero`.
///
/// This function reads Fluent (`.ftl`) files from the specified directory, parses them,
/// and generates a Rust file (`static_cache.rs`) in the `OUT_DIR`.
///
/// # Process
///
/// 1. Scans `locales_dir_path` for language subdirectories (e.g., `en-US`).
/// 2. Parses every `.ftl` file found.
/// 3. Identifies **Static** messages (no variables, standard text) vs **Dynamic** messages.
/// 4. Generates:
///    - `CACHE`: A Perfect Hash Map (PHF) mapping keys to `CacheEntry::Static(&str)` or `CacheEntry::Dynamic`.
///    - `LOCALES`: A Map of Lazy-loaded `ConcurrentFluentBundle`s for fallback/dynamic resolution.
///
/// # Arguments
///
/// * `locales_dir_path` - Relative path to the folder containing locale subdirectories.
#[allow(clippy::too_many_lines)]
pub fn generate_static_cache(locales_dir_path: &str) {
    println!("cargo:rerun-if-changed={locales_dir_path}");

    let out_dir = env::var("OUT_DIR").expect("OUT_DIR not set");
    let dest_path = Path::new(&out_dir).join("static_cache.rs");
    let mut file = fs::File::create(&dest_path).expect("Failed to create static_cache.rs");

    writeln!(&mut file, "// @generated by fluent-zero-build").unwrap();

    let locales_path = Path::new(locales_dir_path);
    if !locales_path.exists() {
        return;
    }

    let mut bundle_entries: Vec<(String, String)> = Vec::new();
    let mut cache_root_entries: Vec<(String, String)> = Vec::new();

    for entry in fs::read_dir(locales_path).unwrap() {
        let entry = entry.unwrap();
        let path = entry.path();

        if path.is_dir() {
            let dir_name = path.file_name().unwrap().to_str().unwrap();
            let lang_id: LanguageIdentifier = match dir_name.parse() {
                Ok(id) => id,
                Err(_) => continue,
            };
            let lang_key = lang_id.to_string();
            let sanitized_lang = lang_key.replace('-', "_").to_uppercase();

            // Define variable names
            let cache_name = format!("CACHE_{sanitized_lang}");
            let bundle_name = format!("BUNDLE_{sanitized_lang}");

            let mut combined_ftl_source = String::new();
            // Vector of (Key, ValueCode)
            let mut cache_entries: Vec<(String, String)> = Vec::new();

            for file_entry in fs::read_dir(&path).unwrap() {
                let file_entry = file_entry.unwrap();
                let file_path = file_entry.path();

                if file_path.extension().is_some_and(|ext| ext == "ftl") {
                    println!("cargo:rerun-if-changed={}", file_path.display());
                    let source = fs::read_to_string(&file_path).unwrap();
                    combined_ftl_source.push_str(&source);
                    combined_ftl_source.push('\n');

                    let ast = parser::parse(source).expect("Failed to parse FTL");
                    for entry in ast.body {
                        if let fluent_syntax::ast::Entry::Message(msg) = entry {
                            // Check if Simple Static
                            // Criteria:
                            // 1. Has a value.
                            // 2. Only one element in the pattern.
                            // 3. That element is Text (not a Variable).
                            // 4. No escape characters (simplifies generation).
                            if let Some(pattern) = &msg.value
                                && pattern.elements.len() == 1
                                && let fluent_syntax::ast::PatternElement::TextElement { value } =
                                    &pattern.elements[0]
                                && !value.contains('\\')
                            {
                                // Entry::Static("value")
                                // Stored directly in the binary .rodata
                                cache_entries.push((
                                    msg.id.name.clone(),
                                    format!("::fluent_zero::CacheEntry::Static(\"{value}\")"),
                                ));
                            } else {
                                // Entry::Dynamic
                                // Requires parsing by FluentBundle at runtime
                                cache_entries.push((
                                    msg.id.name.clone(),
                                    "::fluent_zero::CacheEntry::Dynamic".to_string(),
                                ));
                            }
                        }
                    }
                }
            }

            // 1. Write the Bundle Static Item
            // We use LazyLock to ensure we only parse the FTL for the bundle if we actually
            // hit a dynamic message for this specific locale.
            let escaped_ftl = format!("{combined_ftl_source:?}");
            let bundle_init_code = format!(
                "std::sync::LazyLock::new(|| {{
                    let lang: ::fluent_zero::LanguageIdentifier = \"{lang_key}\".parse().unwrap();
                    let mut bundle = ::fluent_zero::ConcurrentFluentBundle::new_concurrent(vec![lang]); 
                    let res = ::fluent_zero::FluentResource::try_new({escaped_ftl}.to_string()).expect(\"FTL Error\");
                    bundle.add_resource(res).expect(\"Resource Error\");
                    bundle
                }})"
            );

            writeln!(&mut file,
                "static {bundle_name}: std::sync::LazyLock<::fluent_zero::ConcurrentFluentBundle<::fluent_zero::FluentResource>> = {bundle_init_code};"
            ).unwrap();

            bundle_entries.push((lang_key.clone(), format!("&{bundle_name}")));

            // 2. Write Unified Cache Map
            let mut map = phf_codegen::Map::new();
            map.phf_path("::fluent_zero::phf");
            for (k, v) in &cache_entries {
                map.entry(k.as_str(), v.as_str());
            }

            writeln!(
                &mut file,
                "static {}: ::fluent_zero::phf::Map<&'static str, ::fluent_zero::CacheEntry> = {};",
                cache_name,
                map.build()
            )
            .unwrap();
            cache_root_entries.push((lang_key.clone(), cache_name));
        }
    }

    // 3. Generate Root Maps

    // Unified Cache Root
    let mut root_map = phf_codegen::Map::new();
    root_map.phf_path("::fluent_zero::phf");
    for (l, v) in &cache_root_entries {
        root_map.entry(l.as_str(), format!("&{v}"));
    }
    writeln!(&mut file,
        "pub static CACHE: ::fluent_zero::phf::Map<&'static str, &'static ::fluent_zero::phf::Map<&'static str, ::fluent_zero::CacheEntry>> = {};",
        root_map.build()
    ).unwrap();

    // Locales Root
    let mut bundle_map = phf_codegen::Map::new();
    bundle_map.phf_path("::fluent_zero::phf");
    for (l, c) in &bundle_entries {
        bundle_map.entry(l.as_str(), c.as_str());
    }
    writeln!(&mut file,
        "pub static LOCALES: ::fluent_zero::phf::Map<&'static str, &'static std::sync::LazyLock<::fluent_zero::ConcurrentFluentBundle<::fluent_zero::FluentResource>>> = {};",
        bundle_map.build()
    ).unwrap();
}
